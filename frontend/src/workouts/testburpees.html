<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Burpee Rep Counter (Real-time WASM)</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      min-height: 100vh;
    }
    
    .container {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
    }
    
    h2 {
      text-align: center;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .subtitle {
      text-align: center;
      font-size: 1.2em;
      margin-bottom: 30px;
      opacity: 0.9;
    }
    
    #videoContainer {
      position: relative;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    #video { 
      max-width: 100%; 
      width: 640px;
      height: 480px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      background: black;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    
    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    button {
      padding: 12px 24px;
      font-size: 16px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-weight: bold;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    #startBtn {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
    }
    
    #stopBtn {
      background: linear-gradient(45deg, #f44336, #da190b);
      color: white;
    }
    
    #resetBtn {
      background: linear-gradient(45deg, #ff9800, #e68900);
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none;
    }
    
    .stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.15);
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .stat-number {
      font-size: 2.5em;
      font-weight: bold;
      margin-bottom: 5px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .stat-label {
      font-size: 1em;
      opacity: 0.9;
    }
    
    #phase-display {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .phase-indicator {
      display: inline-block;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 25px;
      font-size: 1em;
      font-weight: bold;
      transition: all 0.3s ease;
      border: 2px solid transparent;
    }
    
    .phase-active { 
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
    }
    
    .phase-inactive { 
      background: rgba(255, 255, 255, 0.2);
      color: rgba(255, 255, 255, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .phase-completed {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      border: 2px solid #4CAF50;
    }
    
    #feedback {
      font-size: 1.3em;
      padding: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }
    
    .processing { 
      background: linear-gradient(45deg, #2196F3, #1976D2);
      animation: pulse 2s infinite;
    }
    
    .error { 
      background: linear-gradient(45deg, #f44336, #d32f2f);
      animation: shake 0.5s ease-in-out;
    }
    
    .warning { 
      background: linear-gradient(45deg, #ff9800, #f57c00);
      animation: warning-pulse 1.5s infinite;
    }
    
    .good-form { 
      background: linear-gradient(45deg, #4CAF50, #388e3c);
      animation: success-glow 1s ease-out;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    
    @keyframes warning-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    
    @keyframes success-glow {
      0% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
      50% { box-shadow: 0 0 20px rgba(76, 175, 80, 0.8); }
      100% { box-shadow: 0 0 5px rgba(76, 175, 80, 0.5); }
    }
    
    .permission-prompt {
      text-align: center;
      padding: 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      margin-bottom: 20px;
    }
    
    .camera-icon {
      font-size: 4em;
      margin-bottom: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>üèÉ‚Äç‚ôÇÔ∏è Live Burpee Counter</h2>
    <p class="subtitle">Real-time rep counting with AI-powered form feedback</p>
    
    <div id="videoContainer">
      <video id="video" autoplay muted playsinline></video>
    </div>
    
    <div class="controls">
      <button id="startBtn">üé• Start Camera</button>
      <button id="stopBtn" disabled>‚èπÔ∏è Stop</button>
      <button id="resetBtn">üîÑ Reset Count</button>
    </div>
    
    <div class="stats-container">
      <div class="stat-card">
        <div class="stat-number" id="burpeeCount">0</div>
        <div class="stat-label">Perfect Burpees</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="partialCount">0</div>
        <div class="stat-label">Partial Reps</div>
      </div>
      <div class="stat-card">
        <div class="stat-number" id="totalCount">0</div>
        <div class="stat-label">Total Attempts</div>
      </div>
    </div>
    
    <div id="phase-display">
      <strong>Current Burpee Phase:</strong><br><br>
      <span class="phase-indicator phase-inactive" id="phase-squat">üèãÔ∏è Squat Down</span>
      <span class="phase-indicator phase-inactive" id="phase-pushup">üí™ Push-up</span>
      <span class="phase-indicator phase-inactive" id="phase-return">üîÑ Return to Squat</span>
      <span class="phase-indicator phase-inactive" id="phase-jump">üöÄ Jump Up</span>
    </div>
    
    <div id="feedback" class="processing">Click "Start Camera" to begin live burpee tracking!</div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

    let poseLandmarker, vision;
    let video, stream;
    let animationFrameId = null;
    let isTracking = false;

    // Burpee tracking variables
    let currentPhase = 'standing'; 
    let burpeeCount = 0;
    let partialBurpees = 0;
    let lastFeedback = "";
    let phaseStartTime = 0;
    let phaseConfidence = 0;
    let framesSincePhaseChange = 0;

    // Enhanced push-up tracking
    let pushupCompleted = false;
    let pushupDetectionFrames = 0;
    let minElbowAngleInPhase = 180; // Track the minimum elbow angle during pushup phase
    let completedPhases = {
      squat: false,
      pushup: false,
      return: false,
      jump: false
    };

    // Get DOM elements
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const feedbackDiv = document.getElementById('feedback');
    const burpeeCountDiv = document.getElementById('burpeeCount');
    const partialCountDiv = document.getElementById('partialCount');
    const totalCountDiv = document.getElementById('totalCount');

    async function setupPoseLandmarker() {
      try {
        giveFeedback("Loading AI pose detection model...", "processing");
        
        vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.7,
          minPosePresenceConfidence: 0.7,
          minTrackingConfidence: 0.7,
          outputSegmentationMasks: false,
        });
        
        giveFeedback("AI model loaded successfully! Click 'Start Camera' to begin.", "good-form");
        console.log("PoseLandmarker initialized successfully");
        
      } catch (error) {
        console.error("Failed to initialize PoseLandmarker:", error);
        giveFeedback("Failed to load AI model. Please refresh the page and try again.", "error");
      }
    }

    async function startCamera() {
      try {
        giveFeedback("Requesting camera access...", "processing");
        
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: 'user'
          }
        });
        
        video = document.getElementById('video');
        video.srcObject = stream;
        
        video.onloadeddata = () => {
          startBtn.disabled = true;
          stopBtn.disabled = false;
          isTracking = true;
          
          giveFeedback("Camera ready! Position yourself in frame and start doing burpees!", "good-form");
          
          if (poseLandmarker) {
            processVideo();
          } else {
            giveFeedback("AI model not ready. Please wait...", "warning");
          }
        };
        
      } catch (error) {
        console.error("Camera access error:", error);
        giveFeedback("Camera access denied. Please allow camera permissions and try again.", "error");
      }
    }

    function stopCamera() {
      isTracking = false;
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
        stream = null;
      }
      
      if (video) {
        video.srcObject = null;
      }
      
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      resetPhaseDisplay();
      giveFeedback("Camera stopped. Click 'Start Camera' to resume tracking.", "processing");
    }

    function resetCount() {
      burpeeCount = 0;
      partialBurpees = 0;
      currentPhase = 'standing';
      phaseStartTime = 0;
      phaseConfidence = 0;
      framesSincePhaseChange = 0;
      pushupCompleted = false;
      pushupDetectionFrames = 0;
      minElbowAngleInPhase = 180;
      completedPhases = { squat: false, pushup: false, return: false, jump: false };
      
      updateStats();
      resetPhaseDisplay();
      
      if (isTracking) {
        giveFeedback("Count reset! Continue with your burpees.", "good-form");
      } else {
        giveFeedback("Count reset. Start camera to begin tracking.", "processing");
      }
    }

    function updateStats() {
      burpeeCountDiv.textContent = burpeeCount;
      partialCountDiv.textContent = partialBurpees;
      totalCountDiv.textContent = burpeeCount + partialBurpees;
    }

    function calcAngle(a, b, c) {
      const ab = Math.hypot(b.x - a.x, b.y - a.y);
      const bc = Math.hypot(c.x - b.x, c.y - b.y);
      const ac = Math.hypot(c.x - a.x, c.y - a.y);
      return Math.acos((ab**2 + bc**2 - ac**2) / (2 * ab * bc)) * (180 / Math.PI);
    }

    function updatePhaseDisplay(phase) {
      document.querySelectorAll('.phase-indicator').forEach(el => {
        el.className = 'phase-indicator phase-inactive';
      });
      
      // Mark completed phases
      if (completedPhases.squat) {
        document.getElementById('phase-squat').className = 'phase-indicator phase-completed';
      }
      if (completedPhases.pushup) {
        document.getElementById('phase-pushup').className = 'phase-indicator phase-completed';
      }
      if (completedPhases.return) {
        document.getElementById('phase-return').className = 'phase-indicator phase-completed';
      }
      if (completedPhases.jump) {
        document.getElementById('phase-jump').className = 'phase-indicator phase-completed';
      }
      
      // Mark current active phase
      switch(phase) {
        case 'squatting':
          document.getElementById('phase-squat').className = 'phase-indicator phase-active';
          break;
        case 'pushup':
          document.getElementById('phase-pushup').className = 'phase-indicator phase-active';
          break;
        case 'returning':
          document.getElementById('phase-return').className = 'phase-indicator phase-active';
          break;
        case 'jumping':
          document.getElementById('phase-jump').className = 'phase-indicator phase-active';
          break;
      }
    }

    function resetPhaseDisplay() {
      document.querySelectorAll('.phase-indicator').forEach(el => {
        el.className = 'phase-indicator phase-inactive';
      });
    }

    function giveFeedback(msg, type = "processing") {
      if (msg !== lastFeedback) {
        feedbackDiv.textContent = msg;
        feedbackDiv.className = type;
        lastFeedback = msg;
      }
    }

    function analyzePosture(landmarks) {
      const lm = landmarks[0];
      
      // Key landmarks
      const nose = lm[0];
      const leftShoulder = lm[11], rightShoulder = lm[12];
      const leftElbow = lm[13], rightElbow = lm[14];
      const leftWrist = lm[15], rightWrist = lm[16];
      const leftHip = lm[23], rightHip = lm[24];
      const leftKnee = lm[25], rightKnee = lm[26];
      const leftAnkle = lm[27], rightAnkle = lm[28];

      // Calculate key angles
      const leftKneeAngle = calcAngle(leftHip, leftKnee, leftAnkle);
      const rightKneeAngle = calcAngle(rightHip, rightKnee, rightAnkle);
      const avgKneeAngle = (leftKneeAngle + rightKneeAngle) / 2;

      const leftElbowAngle = calcAngle(leftShoulder, leftElbow, leftWrist);
      const rightElbowAngle = calcAngle(rightShoulder, rightElbow, rightWrist);
      const avgElbowAngle = (leftElbowAngle + rightElbowAngle) / 2;

      // Calculate body positions
      const shoulderHeight = (leftShoulder.y + rightShoulder.y) / 2;
      const hipHeight = (leftHip.y + rightHip.y) / 2;
      const handHeight = (leftWrist.y + rightWrist.y) / 2;
      const noseHeight = nose.y;

      // Position analysis
      const isSquatting = avgKneeAngle < 130 && shoulderHeight > hipHeight - 0.1;
      const isInPushupPosition = handHeight > shoulderHeight && 
                                Math.abs(shoulderHeight - hipHeight) < 0.15 &&
                                noseHeight > shoulderHeight - 0.1;
      const isJumping = avgKneeAngle > 160 && noseHeight < shoulderHeight - 0.1;
      const isStanding = avgKneeAngle > 150 && shoulderHeight < hipHeight;

      return {
        avgKneeAngle,
        avgElbowAngle,
        isSquatting,
        isInPushupPosition,
        isJumping,
        isStanding,
        shoulderHeight,
        hipHeight,
        handHeight,
        noseHeight
      };
    }

    function processBurpeeMovement(posture) {
      framesSincePhaseChange++;
      const minFramesForPhaseChange = 5; // Require consistency over multiple frames

      switch(currentPhase) {
        case 'standing':
          if (posture.isSquatting && framesSincePhaseChange > minFramesForPhaseChange) {
            currentPhase = 'squatting';
            framesSincePhaseChange = 0;
            completedPhases.squat = true;
            updatePhaseDisplay('squatting');
            giveFeedback("üèãÔ∏è Good squat! Now go into push-up position", "good-form");
          }
          break;

        case 'squatting':
          if (posture.isInPushupPosition && framesSincePhaseChange > minFramesForPhaseChange) {
            currentPhase = 'pushup';
            framesSincePhaseChange = 0;
            pushupCompleted = false;
            pushupDetectionFrames = 0;
            minElbowAngleInPhase = 180; // Reset minimum angle tracker
            updatePhaseDisplay('pushup');
            giveFeedback("üí™ Perfect! In push-up position - now do the push-up!", "good-form");
          } else if (framesSincePhaseChange > 60) { // ~2 seconds at 30fps
            giveFeedback("‚ö†Ô∏è Place hands on ground and extend legs back for push-up position", "warning");
          }
          break;

        case 'pushup':
          // Track the minimum elbow angle during this phase
          minElbowAngleInPhase = Math.min(minElbowAngleInPhase, posture.avgElbowAngle);
          
          // Check for push-up completion: elbow angle must go below 100 degrees
          if (posture.avgElbowAngle < 100 && !pushupCompleted) {
            pushupDetectionFrames++;
            if (pushupDetectionFrames >= 3) { // Require 3 consecutive frames
              pushupCompleted = true;
              completedPhases.pushup = true;
              giveFeedback("üí™ Excellent push-up! Now jump back to squat position", "good-form");
            }
          } else if (posture.avgElbowAngle >= 100) {
            pushupDetectionFrames = 0; // Reset if arms extend again without completing
          }
          
          // Only allow progression if push-up was completed
          if (posture.isSquatting && framesSincePhaseChange > minFramesForPhaseChange) {
            if (pushupCompleted) {
              currentPhase = 'returning';
              framesSincePhaseChange = 0;
              completedPhases.return = true;
              updatePhaseDisplay('returning');
              giveFeedback("üîÑ Great! Back to squat - now jump up!", "good-form");
            } else {
              // Push-up not completed properly
              giveFeedback("‚ö†Ô∏è Complete the push-up first! Bend your arms to at least 90 degrees", "warning");
              framesSincePhaseChange = Math.max(0, framesSincePhaseChange - 10); // Reset some frames
            }
          } else if (framesSincePhaseChange > 120) { // ~4 seconds
            if (!pushupCompleted) {
              giveFeedback("‚ö†Ô∏è Do a proper push-up: bend your arms to 90 degrees or less!", "warning");
            } else {
              giveFeedback("‚ö†Ô∏è Jump your feet back to squat position", "warning");
            }
          }
          break;

        case 'returning':
          if ((posture.isJumping || posture.isStanding) && framesSincePhaseChange > minFramesForPhaseChange) {
            currentPhase = 'jumping';
            framesSincePhaseChange = 0;
            updatePhaseDisplay('jumping');
            giveFeedback("üöÄ Jump higher! Extend fully!", "good-form");
          } else if (framesSincePhaseChange > 45) { // ~1.5 seconds
            giveFeedback("‚ö†Ô∏è Jump up explosively from squat position!", "warning");
          }
          break;

        case 'jumping':
          if (posture.isStanding && framesSincePhaseChange > 10) {
            // Only count as complete burpee if all phases were properly completed
            if (completedPhases.squat && completedPhases.pushup && completedPhases.return) {
              burpeeCount++;
              completedPhases.jump = true;
              giveFeedback(`üéâ Burpee #${burpeeCount} completed! Excellent work!`, "good-form");
            } else {
              partialBurpees++;
              giveFeedback(`‚ö†Ô∏è Partial rep #${partialBurpees} - make sure to complete all phases properly!`, "warning");
            }
            
            // Reset for next rep
            currentPhase = 'standing';
            framesSincePhaseChange = 0;
            pushupCompleted = false;
            pushupDetectionFrames = 0;
            minElbowAngleInPhase = 180;
            completedPhases = { squat: false, pushup: false, return: false, jump: false };
            updateStats();
            resetPhaseDisplay();
            
            // Brief celebration before next rep
            setTimeout(() => {
              if (isTracking) {
                giveFeedback("Ready for next burpee! Squat down to start", "processing");
              }
            }, 2000);
            
          } else if (posture.isSquatting && framesSincePhaseChange > 5) {
            // Started next rep without full extension - always partial
            partialBurpees++;
            currentPhase = 'squatting';
            framesSincePhaseChange = 0;
            pushupCompleted = false;
            pushupDetectionFrames = 0;
            minElbowAngleInPhase = 180;
            completedPhases = { squat: true, pushup: false, return: false, jump: false };
            updateStats();
            updatePhaseDisplay('squatting');
            giveFeedback(`‚ö†Ô∏è Partial rep #${partialBurpees} - jump higher and extend fully next time!`, "warning");
          }
          break;
      }

      // Additional form feedback
      if (currentPhase === 'pushup') {
        if (posture.avgElbowAngle > 150 && !pushupCompleted) {
          giveFeedback("‚ö†Ô∏è Bend your arms more for a proper push-up", "warning");
        } else if (Math.abs(posture.shoulderHeight - posture.hipHeight) > 0.25) {
          giveFeedback("‚ö†Ô∏è Keep your body straight - avoid sagging or piking", "warning");
        }
      }

      if (currentPhase === 'squatting' && posture.avgKneeAngle > 140) {
        giveFeedback("‚ö†Ô∏è Squat deeper - bend your knees more", "warning");
      }
    }

    async function processVideo() {
      if (!isTracking || !poseLandmarker) return;

      try {
        const currentTime = performance.now();
        const results = poseLandmarker.detectForVideo(video, currentTime);
        
        if (results.landmarks && results.landmarks.length > 0) {
          const posture = analyzePosture(results.landmarks);
          processBurpeeMovement(posture);
        } else {
          if (framesSincePhaseChange > 60) { // If no pose detected for 2 seconds
            giveFeedback("‚ö†Ô∏è Please stay in camera view for accurate tracking", "warning");
          }
        }
        
      } catch (error) {
        console.error("Error processing video frame:", error);
      }

      if (isTracking) {
        animationFrameId = requestAnimationFrame(processVideo);
      }
    }

    // Event listeners
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    resetBtn.addEventListener('click', resetCount);

    // Initialize
    setupPoseLandmarker();
  </script>
</body>
</html>