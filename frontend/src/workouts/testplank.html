<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Plank Timer with Form Detection</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      color: white;
    }
    
    .container {
      background: rgba(255, 255, 255, 0.1);
      padding: 30px;
      border-radius: 20px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .video-container {
      position: relative;
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    #video { 
      width: 640px;
      height: 480px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 15px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      transform: scaleX(-1); /* Mirror the video */
    }
    
    .controls {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .btn {
      background: linear-gradient(45deg, #4CAF50, #45a049);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.1em;
      border-radius: 25px;
      cursor: pointer;
      margin: 0 10px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    
    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    .btn:disabled {
      background: #666;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn.stop {
      background: linear-gradient(45deg, #f44336, #d32f2f);
    }
    
    .timer {
      font-size: 3em;
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(45deg, #FF6B6B, #FF8E53);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    
    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 20px 0;
    }
    
    .stat-card {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .stat-value {
      font-size: 2em;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 0.9em;
      opacity: 0.8;
    }
    
    #feedback { 
      font-size: 1.3em; 
      margin: 20px 0;
      padding: 20px;
      border-radius: 15px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    
    .processing { 
      background: linear-gradient(45deg, #FFC107, #FF9800);
      animation: pulse 2s infinite;
    }
    
    .error { 
      background: linear-gradient(45deg, #F44336, #D32F2F);
    }
    
    .good-form {
      background: linear-gradient(45deg, #4CAF50, #45a049);
    }
    
    .bad-form {
      background: linear-gradient(45deg, #FF5722, #F44336);
    }
    
    .idle {
      background: rgba(255, 255, 255, 0.1);
      border: 2px dashed rgba(255, 255, 255, 0.3);
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .form-tips {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      margin: 20px 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .form-tips h3 {
      margin-top: 0;
      color: #FFD700;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    
    .form-tips ul {
      margin: 10px 0;
      padding-left: 20px;
    }
    
    .form-tips li {
      margin: 8px 0;
      line-height: 1.4;
    }
    
    .debug-info {
      background: rgba(0, 0, 0, 0.3);
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      font-size: 0.9em;
      font-family: 'Courier New', monospace;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .session-stats {
      background: rgba(255, 255, 255, 0.1);
      padding: 20px;
      border-radius: 15px;
      margin: 20px 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    .session-stats h3 {
      margin-top: 0;
      color: #FFD700;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèãÔ∏è Live Plank Timer with AI Form Detection</h1>
    
    <div class="form-tips">
      <h3>üéØ Proper Plank Form Tips:</h3>
      <ul>
        <li><strong>Straight line:</strong> Keep your body straight from head to heels</li>
        <li><strong>Core engaged:</strong> Tighten your abdominal muscles</li>
        <li><strong>Hip level:</strong> Keep hips level (not too high or too low)</li>
        <li><strong>Neutral spine:</strong> Maintain natural spine alignment</li>
        <li><strong>Shoulder position:</strong> Keep shoulders directly over elbows</li>
        <li><strong>Breathing:</strong> Breathe steadily, don't hold your breath</li>
      </ul>
    </div>

    <div class="video-container">
      <video id="video" autoplay muted playsinline></video>
    </div>
    
    <div class="controls">
      <button id="startBtn" class="btn">Start Camera</button>
      <button id="stopBtn" class="btn stop" disabled>Stop Camera</button>
      <button id="resetBtn" class="btn">Reset Timer</button>
    </div>
    
    <div class="timer" id="timer">00:00</div>
    
    <div class="stats">
      <div class="stat-card">
        <div class="stat-value" id="totalTime">00:00</div>
        <div class="stat-label">Total Plank Time</div>
      </div>
      <div class="stat-card">
        <div class="stat-value" id="sessionCount">0</div>
        <div class="stat-label">Plank Sessions</div>
      </div>
    </div>
    
    <div id="feedback" class="idle">
      üëÜ Click "Start Camera" to begin your plank session
    </div>
    
    <div class="session-stats" id="sessionStats" style="display: none;">
      <h3>üìä Session Statistics</h3>
      <div id="sessionDetails"></div>
    </div>
    
    <div id="debug" class="debug-info" style="display: none;"></div>
  </div>

  <script type="module">
    import {
      FilesetResolver,
      PoseLandmarker,
    } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs";

    // Global variables
    let poseLandmarker = null;
    let vision = null;
    let webcamStream = null;
    let animationFrameId = null;
    let isRunning = false;
    
    // Timing variables
    let plankStartTime = null;
    let currentSessionTime = 0;
    let totalPlankTime = 0;
    let isInPlankPosition = false;
    let consecutiveGoodFrames = 0;
    let consecutiveBadFrames = 0;
    let sessionCount = 0;
    let sessionHistory = [];
    
    // Constants
    const REQUIRED_GOOD_FRAMES = 10; // Require more frames for stability
    const REQUIRED_BAD_FRAMES = 15; // Require more frames before stopping
    const FPS = 30; // Target FPS for processing
    const FRAME_INTERVAL = 1000 / FPS;
    
    // DOM elements
    const video = document.getElementById('video');
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const resetBtn = document.getElementById('resetBtn');
    const timerElement = document.getElementById('timer');
    const feedbackElement = document.getElementById('feedback');
    const debugElement = document.getElementById('debug');
    const totalTimeElement = document.getElementById('totalTime');
    const sessionCountElement = document.getElementById('sessionCount');
    const sessionStatsElement = document.getElementById('sessionStats');
    const sessionDetailsElement = document.getElementById('sessionDetails');

    // Initialize MediaPipe Pose Landmarker
    async function setupPoseLandmarker() {
      try {
        feedbackElement.textContent = "üîÑ Loading AI pose detection model...";
        feedbackElement.className = "processing";
        
        vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5,
          outputSegmentationMasks: false,
        });
        
        console.log("‚úÖ PoseLandmarker initialized successfully");
        feedbackElement.textContent = "‚úÖ AI pose detection ready! Click 'Start Camera' to begin.";
        feedbackElement.className = "idle";
        startBtn.disabled = false;
        
      } catch (error) {
        console.error("‚ùå Failed to initialize PoseLandmarker:", error);
        feedbackElement.textContent = "‚ùå Failed to load pose detection model. Please refresh the page.";
        feedbackElement.className = "error";
      }
    }

    // Calculate angle between three points
    function calcAngle(a, b, c) {
      const ab = Math.hypot(b.x - a.x, b.y - a.y);
      const bc = Math.hypot(c.x - b.x, c.y - b.y);
      const ac = Math.hypot(c.x - a.x, c.y - a.y);
      const angle = Math.acos((ab**2 + bc**2 - ac**2) / (2 * ab * bc)) * (180 / Math.PI);
      return isNaN(angle) ? 180 : angle;
    }

    // Format time in MM:SS format
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    // Update timer display
    function updateTimer() {
      const now = Date.now() / 1000;
      let displayTime = 0;
      
      if (isInPlankPosition && plankStartTime !== null) {
        currentSessionTime = now - plankStartTime;
        displayTime = currentSessionTime;
      } else {
        displayTime = currentSessionTime;
      }
      
      timerElement.textContent = formatTime(displayTime);
      totalTimeElement.textContent = formatTime(totalPlankTime + displayTime);
    }

    // Analyze plank form from pose landmarks
    function analyzePlankForm(landmarks) {
      const lm = landmarks[0];
      
      // Key body points (MediaPipe pose landmarks)
      const nose = lm[0];
      const leftShoulder = lm[11];
      const rightShoulder = lm[12];
      const leftElbow = lm[13];
      const rightElbow = lm[14];
      const leftWrist = lm[15];
      const rightWrist = lm[16];
      const leftHip = lm[23];
      const rightHip = lm[24];
      const leftKnee = lm[25];
      const rightKnee = lm[26];
      const leftAnkle = lm[27];
      const rightAnkle = lm[28];

      // Calculate average positions for stability
      const avgShoulder = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };
      const avgElbow = { x: (leftElbow.x + rightElbow.x) / 2, y: (leftElbow.y + rightElbow.y) / 2 };
      const avgWrist = { x: (leftWrist.x + rightWrist.x) / 2, y: (leftWrist.y + rightWrist.y) / 2 };
      const avgHip = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
      const avgKnee = { x: (leftKnee.x + rightKnee.x) / 2, y: (leftKnee.y + rightKnee.y) / 2 };
      const avgAnkle = { x: (leftAnkle.x + rightAnkle.x) / 2, y: (leftAnkle.y + rightAnkle.y) / 2 };

      // Plank position detection
      const isOnForearms = avgElbow.y > avgShoulder.y && avgWrist.y > avgElbow.y;
      const kneesOffGround = avgKnee.y < (avgAnkle.y - 0.04);
      
      // Body alignment checks
      const hipShoulderDiff = avgHip.y - avgShoulder.y;
      const hipTooHigh = hipShoulderDiff < -0.06;
      const hipTooLow = hipShoulderDiff > 0.06;
      
      // Shoulder-elbow alignment
      const shoulderElbowDistance = Math.abs(avgShoulder.x - avgElbow.x);
      const shouldersOverElbows = shoulderElbowDistance < 0.08;
      
      // Body straightness check
      const bodySlope = Math.abs((avgHip.y - avgShoulder.y) / (avgHip.x - avgShoulder.x + 0.001));
      const isBodyStraight = bodySlope < 0.25;

      // Form feedback messages
      let formFeedback = [];
      let isGoodForm = true;

      if (!isOnForearms) {
        formFeedback.push("üîΩ Get into plank position - forearms on ground");
        isGoodForm = false;
      }

      if (!kneesOffGround) {
        formFeedback.push("‚¨ÜÔ∏è Lift your knees off the ground");
        isGoodForm = false;
      }

      if (hipTooHigh) {
        formFeedback.push("‚¨áÔ∏è Lower your hips - they're too high");
        isGoodForm = false;
      } else if (hipTooLow) {
        formFeedback.push("‚¨ÜÔ∏è Raise your hips - they're sagging");
        isGoodForm = false;
      }

      if (!shouldersOverElbows && isOnForearms) {
        formFeedback.push("üìê Position shoulders directly over elbows");
        isGoodForm = false;
      }

      if (!isBodyStraight && isOnForearms && kneesOffGround) {
        formFeedback.push("üìè Keep your body in a straight line");
        isGoodForm = false;
      }

      // Core plank requirements
      const isValidPlank = isOnForearms && kneesOffGround && !hipTooHigh && !hipTooLow;
      const isPerfectForm = isValidPlank && shouldersOverElbows && isBodyStraight;

      // Debug information
      const debugInfo = {
        isOnForearms,
        kneesOffGround,
        hipTooHigh,
        hipTooLow,
        shouldersOverElbows,
        isBodyStraight,
        bodySlope: bodySlope.toFixed(3),
        hipShoulderDiff: hipShoulderDiff.toFixed(3)
      };

      return {
        isInPlank: isValidPlank,
        isGoodForm: isPerfectForm,
        feedback: formFeedback.length > 0 ? formFeedback : ["üéâ Perfect form! Keep it up!"],
        debug: debugInfo
      };
    }

    // Provide real-time feedback
    function giveFeedback(analysis) {
      const now = Date.now() / 1000;
      
      // Update debug info
      debugElement.innerHTML = `
        <strong>üîç Debug Info:</strong><br>
        Forearms down: ${analysis.debug.isOnForearms ? '‚úÖ' : '‚ùå'}<br>
        Knees off ground: ${analysis.debug.kneesOffGround ? '‚úÖ' : '‚ùå'}<br>
        Hip position: ${analysis.debug.hipTooHigh ? 'üî∫ Too high' : analysis.debug.hipTooLow ? 'üîª Too low' : '‚úÖ Good'}<br>
        Shoulders over elbows: ${analysis.debug.shouldersOverElbows ? '‚úÖ' : '‚ùå'}<br>
        Body straight: ${analysis.debug.isBodyStraight ? '‚úÖ' : '‚ùå'}<br>
        Valid plank: ${analysis.isInPlank ? '‚úÖ' : '‚ùå'}<br>
        Good frames: ${consecutiveGoodFrames} | Bad frames: ${consecutiveBadFrames}
      `;
      
      if (analysis.isInPlank) {
        consecutiveGoodFrames++;
        consecutiveBadFrames = 0;
        
        feedbackElement.textContent = analysis.feedback.join(" ‚Ä¢ ");
        feedbackElement.className = analysis.isGoodForm ? "good-form" : "bad-form";
        
        // Start timing after consecutive good frames
        if (!isInPlankPosition && consecutiveGoodFrames >= REQUIRED_GOOD_FRAMES) {
          plankStartTime = now;
          isInPlankPosition = true;
          currentSessionTime = 0;
          console.log("üü¢ Plank started!");
        }
      } else {
        consecutiveBadFrames++;
        consecutiveGoodFrames = 0;
        
        feedbackElement.textContent = analysis.feedback.join(" ‚Ä¢ ");
        feedbackElement.className = "bad-form";
        
        // Stop timing after consecutive bad frames
        if (isInPlankPosition && consecutiveBadFrames >= REQUIRED_BAD_FRAMES) {
          if (plankStartTime !== null) {
            const sessionTime = now - plankStartTime;
            totalPlankTime += sessionTime;
            sessionCount++;
            sessionHistory.push({
              duration: sessionTime,
              timestamp: new Date()
            });
            
            // Update session stats
            sessionCountElement.textContent = sessionCount;
            updateSessionStats();
            
            plankStartTime = null;
            isInPlankPosition = false;
            currentSessionTime = 0;
            console.log("üî¥ Plank ended. Session time:", formatTime(sessionTime));
          }
        }
      }
    }

    // Update session statistics
    function updateSessionStats() {
      if (sessionHistory.length > 0) {
        sessionStatsElement.style.display = 'block';
        
        const longestSession = Math.max(...sessionHistory.map(s => s.duration));
        const averageSession = sessionHistory.reduce((sum, s) => sum + s.duration, 0) / sessionHistory.length;
        
        sessionDetailsElement.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <div>
              <strong>üèÜ Longest Session:</strong><br>
              ${formatTime(longestSession)}
            </div>
            <div>
              <strong>üìä Average Session:</strong><br>
              ${formatTime(averageSession)}
            </div>
          </div>
          <div style="margin-top: 15px;">
            <strong>üìà Recent Sessions:</strong><br>
            ${sessionHistory.slice(-5).reverse().map((session, index) => 
              `${index + 1}. ${formatTime(session.duration)} - ${session.timestamp.toLocaleTimeString()}`
            ).join('<br>')}
          </div>
        `;
      }
    }

    // Process video frames for pose detection
    let lastProcessTime = 0;
    async function processVideoFrame() {
      if (!isRunning || !poseLandmarker) return;
      
      const now = performance.now();
      
      // Limit processing to target FPS
      if (now - lastProcessTime >= FRAME_INTERVAL) {
        try {
          const results = poseLandmarker.detectForVideo(video, now);
          
          if (results.landmarks && results.landmarks.length > 0) {
            const analysis = analyzePlankForm(results.landmarks);
            giveFeedback(analysis);
          } else {
            // No pose detected
            feedbackElement.textContent = "üîç Move into camera view for pose detection";
            feedbackElement.className = "bad-form";
            
            if (isInPlankPosition) {
              consecutiveBadFrames++;
              if (consecutiveBadFrames >= REQUIRED_BAD_FRAMES) {
                // Stop timing due to no pose detection
                if (plankStartTime !== null) {
                  const sessionTime = Date.now() / 1000 - plankStartTime;
                  totalPlankTime += sessionTime;
                  sessionCount++;
                  sessionHistory.push({
                    duration: sessionTime,
                    timestamp: new Date()
                  });
                  
                  sessionCountElement.textContent = sessionCount;
                  updateSessionStats();
                  
                  plankStartTime = null;
                  isInPlankPosition = false;
                  currentSessionTime = 0;
                }
              }
            }
          }
          
          lastProcessTime = now;
        } catch (error) {
          console.error("Error processing frame:", error);
        }
      }
      
      // Update timer
      updateTimer();
      
      // Continue processing
      if (isRunning) {
        animationFrameId = requestAnimationFrame(processVideoFrame);
      }
    }

    // Start webcam
    async function startWebcam() {
      try {
        feedbackElement.textContent = "üé• Starting camera...";
        feedbackElement.className = "processing";
        
        webcamStream = await navigator.mediaDevices.getUserMedia({
          video: {
            width: { ideal: 640 },
            height: { ideal: 480 },
            facingMode: "user"
          }
        });
        
        video.srcObject = webcamStream;
        await video.play();
        
        isRunning = true;
        startBtn.disabled = true;
        stopBtn.disabled = false;
        
        feedbackElement.textContent = "üìπ Camera active - Position yourself for plank!";
        feedbackElement.className = "idle";
        
        // Start processing
        processVideoFrame();
        
        console.log("‚úÖ Webcam started successfully");
        
      } catch (error) {
        console.error("‚ùå Error starting webcam:", error);
        feedbackElement.textContent = "‚ùå Error accessing camera. Please check permissions.";
        feedbackElement.className = "error";
      }
    }

    // Stop webcam
    function stopWebcam() {
      isRunning = false;
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
        webcamStream = null;
      }
      
      video.srcObject = null;
      
      // Stop current session if active
      if (isInPlankPosition && plankStartTime !== null) {
        const sessionTime = Date.now() / 1000 - plankStartTime;
        totalPlankTime += sessionTime;
        sessionCount++;
        sessionHistory.push({
          duration: sessionTime,
          timestamp: new Date()
        });
        
        sessionCountElement.textContent = sessionCount;
        updateSessionStats();
      }
      
      // Reset timing variables
      plankStartTime = null;
      isInPlankPosition = false;
      currentSessionTime = 0;
      consecutiveGoodFrames = 0;
      consecutiveBadFrames = 0;
      
      startBtn.disabled = false;
      stopBtn.disabled = true;
      
      feedbackElement.textContent = "üì∑ Camera stopped. Click 'Start Camera' to resume.";
      feedbackElement.className = "idle";
      
      console.log("üì∑ Webcam stopped");
    }

    // Reset timer and statistics
    function resetTimer() {
      // Stop current session
      if (isInPlankPosition && plankStartTime !== null) {
        const sessionTime = Date.now() / 1000 - plankStartTime;
        totalPlankTime += sessionTime;
      }
      
      // Reset all timing variables
      plankStartTime = null;
      isInPlankPosition = false;
      currentSessionTime = 0;
      totalPlankTime = 0;
      sessionCount = 0;
      sessionHistory = [];
      consecutiveGoodFrames = 0;
      consecutiveBadFrames = 0;
      
      // Update display
      timerElement.textContent = "00:00";
      totalTimeElement.textContent = "00:00";
      sessionCountElement.textContent = "0";
      sessionStatsElement.style.display = 'none';
      
      if (isRunning) {
        feedbackElement.textContent = "üîÑ Timer reset - Position yourself for plank!";
        feedbackElement.className = "idle";
      }
      
      console.log("üîÑ Timer and statistics reset");
    }

    // Event listeners
    startBtn.addEventListener('click', startWebcam);
    stopBtn.addEventListener('click', stopWebcam);
    resetBtn.addEventListener('click', resetTimer);

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (isRunning) {
          stopWebcam();
        } else if (!startBtn.disabled) {
          startWebcam();
        }
      } else if (e.code === 'KeyR') {
        e.preventDefault();
        resetTimer();
      }
    });

    // Show/hide debug info (click on timer)
    timerElement.addEventListener('click', () => {
      debugElement.style.display = debugElement.style.display === 'none' ? 'block' : 'none';
    });

    // Initialize the application
    window.addEventListener('load', () => {
      console.log("üöÄ Initializing Live Plank Timer...");
      setupPoseLandmarker();
    });

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (isRunning) {
        stopWebcam();
      }
    });
  </script>
</body>
</html>